#include<stdio.h>#include<pthread.h>#include<unistd.h>#include<stdlib.h>#include<string.h>#include<fcntl.h>#include<signal.h>#include <stdbool.h>#include "RGBLed_2.h"int main() {    input_data = read_input_file(); //Read the input.txt file and store the required params in a global struct    if(check_valid_pin(input_data.red_led) < 0 || check_valid_pin(input_data.green_led) < 0 || check_valid_pin(input_data.blue_led) < 0) { //Terminate execution if the pins are invalid        printf("\n\nInvalid PWM pins. Check the input file and/or pin connections\n\n");        goto exit;    }		current_duty_cycle = input_data.duty_cycle; //Set the duty_cycle value globally	printf("Current Duty cycle %0.2f\n", current_duty_cycle);    IOSetup(input_data); //Configure the PWM and GPIO pins for Red, Green and Blue LEDs    create_mouse_thread(); //Mouse thread to handle click events    create_lightup_thread(input_data); // Thread to execute the LED pattern	sleep(60); //Program will execute for 1 minute and then exit    exit:		signal(SIGUSR1, signal_handler_mouse); //Set the signal handler on the mouse thread				pthread_kill(mouse_thread, SIGUSR1); //Notify the mouse thread for exiting        pthread_join(mouse_thread, NULL);  //Wait for the thread to terminate		signal(SIGUSR1, signal_handler_lightup); //Set the signal handler on the lightup sequence thread				pthread_kill(lightup_thread, SIGUSR1); //Notify the lightup sequence thread for exiting        pthread_join(lightup_thread, NULL); //Wait for the thread to terminate        printf("\n\nExiting\n\n");		return 0;}/* Export the gpio pin data struct from the kernel*/int gpio_export(char *gpio){	int fd;	fd = open(SYSFS_GPIO_DIR "/export", O_WRONLY);	if (fd < 0) {		perror("gpio/export");		return fd;	}	write(fd, gpio, strlen(gpio));	close(fd);	return 0;}/* Set  the direction of the gpio pin*/int gpio_set_dir(char *gpio, char *out_dir){	int fd;	char buf[MAX_BUF];	snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR  "/gpio%s/direction", gpio);	printf("Gpio Set direction - %s %s\n", buf, out_dir);	fd = open(buf, O_WRONLY);	if (fd < 0) {		perror("gpio/direction");		return fd;	}	if (strcmp(out_dir, "out") == 0)		write(fd, "out", 3);	else		write(fd, "in", 2);	close(fd);	return 0;}/* Enable/Disable the gpio pin*/int gpio_set_value(char *gpio, char *value){	int fd;	char buf[MAX_BUF];	snprintf(buf, sizeof(buf), SYSFS_GPIO_DIR "/gpio%s/value", gpio);	printf("Gpio Set value - %s %s\n", buf, value);	fd = open(buf, O_WRONLY);	if (fd < 0) {		perror("gpio/set-value");		return fd;	}	if (strcmp(value,"1") == 0)		write(fd, "1", 1);	else		write(fd, "0", 1);	close(fd);	return 0;}/* Configure the pwm pin's duty_cycle*/int pwm_set_duty_cycle(char pwm[MAX_BUF], char *value){	int fd;	char buf[MAX_BUF];	snprintf(buf, sizeof(buf), SYSFS_PWM_DIR "/pwm%s/duty_cycle", pwm);	printf("PWM Set duty_cycle - %s %s\n", buf, value);	fd = open(buf, O_WRONLY);	if (fd < 0) {		perror("pwm/duty_cycle");		return fd;	}	write(fd, value, strlen(value));	close(fd);	return 0;}/* Export the pwm pin data struct from the kernel*/int pwm_export(char *pwm){	int fd;	fd = open(SYSFS_PWM_DIR "/export", O_WRONLY);	if (fd < 0) {		perror("pwm/export");		return fd;	}	write(fd, pwm, strlen(pwm));	close(fd);	return 0;}/* Set the pwm polarity. Either "normal" or "inversed"*/int pwm_set_polarity(char *pwm, char *out_dir){	int fd;	char buf[MAX_BUF];	snprintf(buf, sizeof(buf), SYSFS_PWM_DIR  "/pwm%s/polarity", pwm);	printf("PWM Set polarity - %s %s\n", buf, out_dir);	fd = open(buf, O_WRONLY);	if (fd < 0) {		perror("pwm/polarity");		return fd;	}	if (strcmp(out_dir, "out") == 0)		write(fd, "out", 3);	else		write(fd, "in", 2);	close(fd);	return 0;}/* Enable/Disable the pwm pin*/int pwm_set_enable(char *pwm, char *value){	int fd;	char buf[MAX_BUF];	snprintf(buf, sizeof(buf), SYSFS_PWM_DIR "/pwm%s/enable", pwm);	printf("PWM Set enable - %s %s\n", buf, value);	fd = open(buf, O_WRONLY);	if (fd < 0) {		perror("pwm/enable");		return fd;	}	if (strcmp(value,"1") == 0)		write(fd, "1", 1);	else		write(fd, "0", 1);	close(fd);	return 0;}/* Set the pwm period*/int pwm_set_period(char *value){	int fd;	char buf[MAX_BUF];	snprintf(buf, sizeof(buf), SYSFS_PWM_DIR "/device/pwm_period");	printf("PWM Set period - %s %s\n", buf, value);	fd = open(buf, O_WRONLY);	if (fd < 0) {		perror("pwm/period");		return fd;	}	write(fd, value, strlen(value));	close(fd);	return 0;}/* Set multiple parameters for pwm*/int mux_pwm_set(char *gpio, char *out_dir, char *value, bool isPin){	if(isPin) {        pwm_export(gpio);        pwm_set_polarity(gpio, out_dir);    }    else {        gpio_export(gpio);        gpio_set_dir(gpio, out_dir);        gpio_set_value(gpio, value);	}	return 0;}/* Set multiple parameters for gpio*/int mux_gpio_set(char *gpio, char *out_dir, char *value, bool isPin){	gpio_export(gpio);	gpio_set_dir(gpio, out_dir);	if(!isPin)		gpio_set_value(gpio, value);	return 0;}void* mouse_thread_body(void *arguments) {	//Variables to detect click events	 int left, right, fd, bytes;     unsigned char data[4];    const char *mDevice = MOUSE_DEV; //Default mouse input file on linux (Works for any available mouse)    fd = open(mDevice, O_RDWR); //Open the mouse file    if(fd == -1)    {        printf("ERROR Opening %s\n", mDevice);		goto mouse_exit;    }    while(1) {        bytes = read(fd, data, sizeof(data));        if(bytes > 0) {			// Extract mouse events from the received data			left = data[0] & 0x01;            right = data[0] & 0x02;            if(left == 1) {                printf("Left mouse click\n");				modify_pwm_parameters(LEFT_CLICK_VALUE);            }            if(right == 2) {                printf("Right mouse click\n");				modify_pwm_parameters(RIGHT_CLICK_VALUE);            }        }    }	mouse_exit:		printf("Mouse thread exiting\n");		pthread_exit(NULL);		return NULL;}int create_mouse_thread() {	int err = pthread_create(&mouse_thread, NULL, &mouse_thread_body, NULL);	if (err != 0) {		printf("\nCan't create mouse thread :[%s]", strerror(err));	}	else {		printf("\n Mouse Thread created successfully\n");    }	return 0;}void* lightup_sequence() {    int row, seq_column = 0;    int rows_of_pattern_array = ROW_SIZE(lightup_pattern_array);    printf("\nLightup Thread created successfully. Step count %d\n", rows_of_pattern_array);    printf("\nPattern array %s\n", pwm_mapping_array[input_data.red_led][PIN_COLUMN]);    while(1) {        for(row = 0; row < rows_of_pattern_array; row++) {  // Loop to control the steps of the sequence            char* r = lightup_pattern_array[row][seq_column];            char* g = lightup_pattern_array[row][seq_column+1];            char* b = lightup_pattern_array[row][seq_column+2];	        char* red_led = pwm_mapping_array[input_data.red_led][PIN_COLUMN];	        char* green_led = pwm_mapping_array[input_data.green_led][PIN_COLUMN];	        char* blue_led = pwm_mapping_array[input_data.blue_led][PIN_COLUMN];            printf("\nPattern: R:%s G:%s B:%s\n", r, g, b); //Prints the current R, G, B pattern on the screen            pwm_set_enable(red_led, r);            pwm_set_enable(green_led, g);            pwm_set_enable(blue_led, b);            usleep(((int) STEP_PERIOD_MS) * ((int) SLEEP_PERIOD_MULTIPLIER_US)); //Sleep for the step period        }    }    printf("Sequence thread exiting\n");    pthread_exit(NULL);}/* Create the lightup thread which manages the step sequence*/int create_lightup_thread(struct task_params_struct input_data) {	int err = pthread_create(&lightup_thread, NULL, &lightup_sequence, NULL);	if (err != 0) {		printf("\nCan't create lightup thread :[%s]", strerror(err));		return err;	}	return 0;}/* Reads the input file and saves the required params in a global struct*/struct task_params_struct read_input_file() {	struct task_params_struct params;	char *c = NULL;	ssize_t nread;	size_t len = 0;	FILE *input_file;	input_file = fopen("input.txt", "r"); //open the input file	while((nread = getline(&c,&len,input_file)) != -1) {		params.duty_cycle = (float) (atoi(strsep(&c, ",")) / 100.0);		//Save the duty cycle as a percent_value		params.red_led = atoi(strsep(&c, ","));		params.green_led = atoi(strsep(&c, ","));		params.blue_led = atoi(strsep(&c, ","));		printf("Duty cycle - %0.2f\n", params.duty_cycle);		printf("Red led is on IO%d\n", params.red_led);		printf("Green led is on IO%d\n", params.green_led);		printf("Blue led is on IO%d\n", params.blue_led);	}	fclose(input_file);	return params;}/*	Configure the R, G, and B leds as per the level shifter and mux configuration*/void configure_pwm(int gpio_array_row) {    int column;    int columns_of_pwm_array = COLUMN_SIZE(pwm_mapping_array);    for(column = 0; column < columns_of_pwm_array; column++) {        char *read_value = pwm_mapping_array[gpio_array_row][column];        if(strcmp(read_value, "X") != 0) { //Ignore the value the pin if "X" is set in the mapping array            printf("\n\nConfigure pins for IO %d - %s\n\n", gpio_array_row, pwm_mapping_array[gpio_array_row][column]);            if(column == PIN_COLUMN)                mux_pwm_set(pwm_mapping_array[gpio_array_row][column], "out", "-1", true); //Configure the pwm pin            else if(column == LEVEL_SHIFTER_COLUMN)                mux_pwm_set(pwm_mapping_array[gpio_array_row][column], pwm_values_array[gpio_array_row][column], "0", false); //Configure the level shifter pin            else if(column == MUX_1_COLUMN)                mux_pwm_set(pwm_mapping_array[gpio_array_row][column], "out", pwm_values_array[gpio_array_row][column], false); //Configure the MUX 1 pin            else if(column == MUX_2_COLUMN)                mux_pwm_set(pwm_mapping_array[gpio_array_row][column], "out", pwm_values_array[gpio_array_row][column], false); //Configure the MUX 2 pin        }    }}float calculate_duty_cycle(int left_or_right) {	if(left_or_right == LEFT_CLICK_VALUE) {		current_duty_cycle = current_duty_cycle + 0.1; //Increase the duty cycle by 10% on left mouse click		if(current_duty_cycle > DUTY_CYCLE_MAX) {			current_duty_cycle = 1;		}	} else if (left_or_right == RIGHT_CLICK_VALUE) {		current_duty_cycle = current_duty_cycle - 0.1; //Decrese the duty cycle by 10% on right mouse click		if(current_duty_cycle < DUTY_CYCLE_MIN) {			current_duty_cycle = 0;		}	}	return current_duty_cycle;}/*	Modify the PWM duty cycle and period on mouse click*/void modify_pwm_parameters(int left_or_right) {    char duty_cycle_char[MAX_BUF];	char period[MAX_BUF];    sprintf(period, "%ld", (long) INTENSITY_CONTROL_PERIOD_NS);	printf("Set PWM period %s\n", period);    pwm_set_period(period);	printf("Current Duty cycle %0.2f\n", current_duty_cycle);	printf("Updated Duty cycle %0.2f\n", calculate_duty_cycle(left_or_right));    sprintf(duty_cycle_char, "%d\n", (int) (current_duty_cycle * ((int) INTENSITY_CONTROL_PERIOD_NS)));	printf("Updated Duty cycle %s\n", duty_cycle_char);    pwm_set_duty_cycle(pwm_mapping_array[input_data.red_led][PIN_COLUMN], duty_cycle_char);    pwm_set_duty_cycle(pwm_mapping_array[input_data.green_led][PIN_COLUMN], duty_cycle_char);    pwm_set_duty_cycle(pwm_mapping_array[input_data.blue_led][PIN_COLUMN], duty_cycle_char);	}/*	Configure the R, G, and B leds as per the level shifter and mux configuration	Set the PWM duty cycle and period*/void IOSetup(struct task_params_struct pin_data) {    configure_pwm(pin_data.red_led);    configure_pwm(pin_data.blue_led);    configure_pwm(pin_data.green_led);    modify_pwm_parameters(0);}/* Signal handler to terminate the mouse thread*/static void signal_handler_mouse(int signum) {	if(signum == SIGUSR1) {		pthread_cancel(mouse_thread);	}}/* Signal handler to terminate the lightup sequence thread*/static void signal_handler_lightup(int signum) {	if(signum == SIGUSR1) {		pthread_cancel(lightup_thread);	}}/* Checks whether the IO pins for PWM are correctly configured*/int check_valid_pin(int digit) {	int i;	int pwm_pins[6] = {3, 5, 6, 9, 10, 11}; //Each number represents an IO pin	for(i = 0; i < sizeof(pwm_pins); i++) {		if(digit == pwm_pins[i]) {			return 0;		}	}	return -1;}